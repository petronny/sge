remote_startup(5)          Grid Engine User Commands         remote_startup(5)



NNAAMMEE
       Remote startup - the Grid Engine remote startup mechanism

DDEESSCCRRIIPPTTIIOONN
       Grid  Engine  supports  several commands to facilitate interactive com-
       mands or remote startup of a tightly integrated parallel job. Each com-
       mand  can be set up with _q_c_o_n_f(1) to use different daemons and commands
       to start the final session. Different  startup  methods  can  therefore
       contain  different  daemons  and commands, and are not related to other
       startup methods in any way, although it is often desirable to have  the
       same communication method for all startup methods.

       Each method requires a separate instance of the communication daemon to
       be started by _s_g_e___s_h_e_p_h_e_r_d(8) for each job, which thus must use a  ran-
       domly-chosen  port,  to  which the client will try to connect.  This is
       necessary to support tight integration, ensuring that everything for  a
       given job stays in the same process tree and can be properly controlled
       and accounted by Grid Engine.

QQLLOOGGIINN
       An interactive qqllooggiinn session invoked by  _q_l_o_g_i_n(1)  will  show  up  in
       qqssttaatt  with  the  default  name  QQLLOOGGIINN  unless  changed by the --NN _n_a_m_e
       option.  The two entries qqllooggiinn__ddaaeemmoonn and qqllooggiinn__ccoommmmaanndd are responsi-
       ble for establishing the communication to start such a session.

       The  default  is  the value bbuuiillttiinn, which will trigger an SGE internal
       communication method:

              qqllooggiinn__ccoommmmaanndd      builtin
              qqllooggiinn__ddaaeemmoonn       builtin

       In cases where you want a different communication method, it  can  also
       be  set  up for the formerly-used communication method based on tteellnneett.
       Despite the fact that tteellnneett is used, there is no need to have  tteellnneettdd
       running  all  the time - SGE will start a unique one for each job, even
       when it's from the same user, and telnet can stay disabled as a  system
       service  (whether under init or inetd).  Only the file /etc/hosts.equiv
       needs to contain the name of the machines from where a _q_l_o_g_i_n(1) should
       be  allowed.  This  is  often the head node of a cluster, or particular
       submit machines.  Using telnet, the traffic is not encrypted, but  that
       may  be  reasonable  on a private subnet for the cluster, especially if
       SGE's CSP security isn't used to secure the system generally.

       To achieve this:

              qqllooggiinn__ccoommmmaanndd      /usr/bin/telnet
              qqllooggiinn__ddaaeemmoonn       /usr/sbin/in.telnetd

       must be defined in _s_g_e___c_o_n_f(5).  The defined qqllooggiinn__ccoommmmaanndd  will  then
       be called with two additional parameters: 'HOST', and 'PORT' in exactly
       that order, which  refer  to  the  machine  the  qqllooggiinn__ccoommmmaanndd  should
       address and the port to be used.

       This  can  also be used to set up secure communication using SSSSHH (which
       can also provide X and credential forwarding, as well as  compression).
       In this case a small wrapper must be implemented, whose sole purpose is
       to swap the two given arguments and prepend --pp to the port argument:

              qqllooggiinn__ccoommmmaanndd      _p_a_t_h___t_o___q_l_o_g_i_n___w_r_a_p_p_e_r
              qqllooggiinn__ddaaeemmoonn       /usr/sbin/sshd -i

       and a _p_a_t_h___t_o___q_l_o_g_i_n___w_r_a_p_p_e_r script:

              #!/bin/sh
              HOST=$1
              PORT=$2
              exec /usr/bin/ssh -X -p $PORT $HOST

QQRRLLOOGGIINN
       An interactive qqrrllooggiinn session invoked by  _q_r_s_h(1)  wwiitthhoouutt  a  command
       will show up in qqssttaatt having the default name QQRRLLOOGGIINN unless changed by
       the --NN _n_a_m_e option.  The two entries rrllooggiinn__ddaaeemmoonn  and  rrllooggiinn__ccoommmmaanndd
       are responsible for establishing the command to start such a session.

       The  default  is  the value bbuuiillttiinn, which will trigger an SGE internal
       communication method:

              rrllooggiinn__ccoommmmaanndd      builtin
              rrllooggiinn__ddaaeemmoonn       builtin

       In cases where you want a different communication method, it can follow
       the formerly-used communication method based on rrllooggiinn.  As for telnet,
       rlogin can stay disabled as a system service  (whether  under  init  or
       inetd).   Only  the  file /etc/hosts.equiv needs to contain the name of
       the machines from where a _q_r_s_h(1) should be allowed. This is often  the
       head  node  of a cluster, or particular submit machines.  Using rrllooggiinn,
       the traffic is not encrypted, but that may be reasonable on  a  private
       subnet  for the cluster, especially if SGE's CSP security isn't used to
       secure the system generally.

       To achieve this:

              rrllooggiinn__ccoommmmaanndd      $SGE_ROOT/utilbin/_$_A_R_C/rlogin
              rrllooggiinn__ddaaeemmoonn       /usr/sbin/in.rlogind

       must be defined  in  _s_g_e___c_o_n_f(5).   The  value  of  _$_S_G_E___R_O_O_T  must  be
       replaced  by the root of the installation, and _$_A_R_C must be replaced by
       the particular platform architecture, as use of  environment  variables
       is  not implemented for these entries. When the cluster is homogeneous,
       it can be set to e.g. 'lx24-amd64' or 'lx24-x86'.  In  a  heterogeneous
       cluster  local  configurations need to be defined, where preferably the
       minority of machines will get local configurations.

       The defined rrllooggiinn__ccoommmmaanndd will then be called  with  three  additional
       parameters:  '-p','PORT', and 'HOST''PORT' in exactly that order, which
       refer to the machine the rrllooggiinn__ccoommmmaanndd should address and the port  to
       be used.

       This can also be used to set up a secure communication using SSSSHH:

              rrllooggiinn__ccoommmmaanndd      /usr/bin/ssh
              rrllooggiinn__ddaaeemmoonn       /usr/sbin/sshd -i

QQRRSSHH
       An  interactive  session for a remote command invoked by _q_r_s_h(1) wwiitthh a
       command will show up in qqssttaatt by  default  with  name  of  the  command
       issued, unless changed by the --NN _n_a_m_e option.  The two entries rrsshh__ddaaee--
       mmoonn and rrsshh__ccoommmmaanndd are responsible for establishing the  communication
       to  start such a session.  This startup method will also be used by the
       master task of a tightly integrated parallel job to  start  slave  pro-
       cesses on other granted exechosts.

       The  default  is  the value bbuuiillttiinn, which will trigger an SGE internal
       communication method:

              rrsshh__ccoommmmaanndd         builtin
              rrsshh__ddaaeemmoonn          builtin

       In cases where you want a different communication method, it  can  also
       be  set up for the formerly-used communication method based on rrsshh.  As
       for telnet, rsh can stay disabled as a system  service  (whether  under
       init  or  inetd).   Only the file /etc/hosts.equiv needs to contain the
       name of the machines from where a _q_r_s_h(1) should be  allowed.  This  is
       often the head node of a cluster, or particular submit machines.  Using
       rrsshh, the traffic is not encrypted, but that may be reasonable on a pri-
       vate  subnet  for  the  cluster, especially if SGE's CSP security isn't
       used to secure the system generally.

       To achieve this:

              rrsshh__ccoommmmaanndd         $SGE_ROOT/utilbin/_$_A_R_C/rsh
              rrsshh__ddaaeemmoonn          $SGE_ROOT/utilbin/_$_A_R_C/rshd -l

       must be defined  in  _s_g_e___c_o_n_f(5).   The  value  of  _$_S_G_E___R_O_O_T  must  be
       replaced  by the root of the installation, and _$_A_R_C must be replaced by
       the particular platform architecture, as use of  environment  variables
       is  not implemented for these entries. When the cluster is homogeneous,
       it can be set to e.g. 'lx24-amd64' or 'lx24-x86'.  In  a  heterogeneous
       cluster  local  configurations need to be defined, where preferably the
       minority of machines will get local configurations.

       The defined rrsshh__ccoommmmaanndd will then be called with four additional param-
       eters:  '-n',  '-p',  'PORT',  and  'HOST' in exactly that order, which
       refer to the machine the rrsshh__ccoommmmaanndd should address and the port to  be
       used.

       This can also be used to set up a secure communication using SSSSHH:

              rrsshh__ccoommmmaanndd         /usr/bin/ssh
              rrsshh__ddaaeemmoonn          /usr/sbin/sshd -i
       Again, this is independent of SSH as a system service, which can remain
       disabled.

LLOOCCAALL CCOONNFFIIGGUURRAATTIIOONNSS OOFF EEXXEECCHHOOSSTTSS
       It is important to note that the communication method set  up  for  one
       particular  startup  method  must match at each end. This can either be
       achieved by using only a global configuration, or carefully setting  up
       local  configurations  for the exechosts involved. Whether or not local
       configurations exist, which must be taken care of, can be checked  with
       qqccoonnff --ssccoonnffll.

       As  a  general  rule,  for  setting up a communication method between a
       machine A (where the ccoommmmaanndd is issued) and a machine B (where the ddaaee--
       mmoonn is started) it must be guaranteed that the:

              setup communication method for the ccoommmmaanndd on machine A
              (either  global configuration from _s_g_e___c_o_n_f(5) or local configu-
              ration qqccoonnff --ssccoonnff AA of machine A)

       matches

              setup communication method for the ddaaeemmoonn for machine B
              (either global configuration from _s_g_e___c_o_n_f(5) or local  configu-
              ration qqccoonnff --ssccoonnff BB of machine B)

       This  way  it  is also possible to use different communication methods,
       depending whether a connection from A to B is invoked, or from B to A.

RREESSTTRRIICCTTIIOONNSS
       For all three communication methods, a direct  connection  between  the
       target  and  the source machine where the particular command was issued
       must exist. This can also be implemented using TCP/IP  forwarding,  but
       will  usually  fail  if one machine is behind NNAATT which will mangle the
       machines' addresses.  The communication methods won't work with  simple
       firewalling  of the exec hosts since the methods use a random port.  It
       may be possible to set up application-specific firewalling,  if  neces-
       sary, or to wrap the methods and start an SSH tunnel on the port speci-
       fied for each communication instance.

       The bbuuiillttiinn method does not support forwarding of X graphics  from  the
       compute  nodes,  or GSSAPI tokens to them.  If you need that for any of
       the remote methods, you will want to set up SSH communication instead.

SSSSHH AAUUTTHHEENNTTIICCAATTIIOONN
       To allow the SSSSHH setup explained  above  to  work,  the  user  must  be
       authenticated  without  the  use  of  a  _p_a_s_s_p_h_r_a_s_e.  While  entering a
       _p_a_s_s_p_h_r_a_s_e would still work for interactive commands, it will  fail  in
       case  of  a  tightly  integrated parallel job, where the master process
       tries to start a slave process on another exechost.

       You can set up _p_a_s_s_p_h_r_a_s_e_l_e_s_s SSSSHH kkeeyyss, although this is discouraged. A
       simpler and global working setup is to use host-based authentication
       <http://arc.liv.ac.uk/SGE/howto/hostbased-ssh.html>  for  the  machines
       inside the cluster.

SSSSHH TTIIGGHHTT IINNTTEEGGRRAATTIIOONN
       To  have a tight integration of SSSSHH into SGE, the started sssshhdd needs an
       additional group ID to be attached.  With this additional group ID, SGE
       is able to record the resource consumption and computing time in a cor-
       rect way.  Also a qqddeell of such a job will be able to succeed.

       Such a tight SSH integration can be achieved by two means:

       RReeccoommppiillee GGrriidd EEnnggiinnee wwiitthh ..//aaiimmkk --ttiigghhtt--sssshh ......
              The source of Grid Engine contains the  necessary  additions  to
              compile  a  modified _s_s_h_d, which will honor the additional group
              ID and attach it also to the started process. It's necessary  to
              provide  the source of _O_p_e_n_S_S_H in the directory _3_r_d___p_a_r_t_y inside
              _$_S_G_E___R_O_O_T having a plain name 'openssh'. Inside  this  directory
              the file _s_s_h_d_._c needs to be patched:

              in main():
                     init_rng();
                     #ifdef SGESSH_INTEGRATION
                     sgessh_readconfig();
                     #endif

              in privsep_postauth():
                     /* Drop privileges */
                     #ifdef SGESSH_INTEGRATION
                     sgessh_do_setusercontext(aut hctxt->pw);
                     #else
                     do_setusercontext(authctxt->pw);
                     #endif

              See the original documentation <http://gridengine.org/assets/
              static/ws2007/SGE-openSSHTightIntegration.RonChen.pdf>.

       UUssee ooff PPAAMM
              On supported platforms (at least  GNU/Linux),  a  _p_a_m(7)  module
              _p_a_m___s_g_e_-_q_r_s_h_-_s_e_t_u_p(8)  is available which attaches the necessary
              additional group ID to the  started  process  to  provide  tight
              integration.  See also the workshop paper <http://
              gridengine.org/assets/static/ws2007/K5SGE.pdf>.

RREESSTTRRIICCTTIINNGG AACCCCEESSSS
       With the builtin method in use, there is no need to allow direct access
       for  normal users to compute nodes with ssh etc.  However, you may want
       to allow users to access the nodes for debugging.  If you don't want to
       over-subscribe the nodes, so that qrsh etc. can be used for access, you
       can use PAM to restrict access for a user only to the  nodes  on  which
       they have a running job, so as to minimize interference with other oth-
       ers.

       There are two possible ways.  The cleanest  uses  _p_a_m___s_g_e___a_u_t_h_o_r_i_z_e(8).
       Otherwise  you  can  use  generic PAM modules, such as _p_a_m___l_i_m_i_t_s(8) or
       _p_a_m___a_c_c_e_s_s(8), with modifications to their  configuration  set  up  and
       taken  down  in  the  job  prolog  and  epilog  respectively.  See, for
       instance, a user list message <http://gridengine.markmail.org/message/
       mu3i7haeshlevu6q?q=282211>, and other examples of similar prolog/epilog
       scripts provided with locking in the pam_authuser contribution  in  the
       Torque distribution.

EEXXAAMMPPLLEESS
       Using  SSH  with the PAM module, forcing tty allocation, and preventing
       the delegation of GSSAPI credentials to the compute nodes:
              rsh_daemon     /opt/sge/util/rshdwrapper
              rsh_command    ssh -tt -o GSSAPIDelegateCredentials=no
              qlogin_daemon  /opt/sge/util/rshdwrapper
              qlogin_command ssh -tt -o GSSAPIDelegateCredentials=no
              rlogin_daemon  /opt/sge/util/rshdwrapper
              rlogin_command ssh -tt -o GSSAPIDelegateCredentials=no

       Old-style method, using telnet and rlogin:
              qlogin_command /usr/bin/telnet
              qlogin_daemon  /usr/sbin/in.telnetd
              rlogin_command /opt/sge/utilbin/lx24-x86/rlogin
              rlogin_daemon  /usr/sbin/in.rlogind
              rsh_command    /opt/sge/utilbin/lx24-x86/rsh
              rsh_daemon     /opt/sge/utilbin/lx24-x86/rshd -l

SSEEEE AALLSSOO
       _q_c_o_n_f(1),  _q_l_o_g_i_n(1),   _q_r_s_h(1),   _s_g_e___c_o_n_f(5),   _p_a_m___s_g_e___a_u_t_h_o_r_i_z_e(8),
       _p_a_m___s_g_e_-_q_r_s_h_-_s_e_t_u_p(8), Grid Engine-specific remote programs <http://
       arc.liv.ac.uk/repos/darcs/sge/source/3rdparty/remote/remote.html>.

AAUUTTHHOORR
       Man page written by Reuti, partly based on Sun  material.   Some  addi-
       tions by Dave Love.

CCOOPPYYRRIIGGHHTT
       See _s_g_e___i_n_t_r_o(1) for a full statement of rights and permissions.



SGE 8.0.0                     2010/11/22 20:58:24            remote_startup(5)
